This paper proposed a 32-way multithreaded SPARK processor called Niagara. Based on the observations that much effort was spent to make single-core processors run faster by exploiting instruction level parallelism (ILP), but many commercial server applications have emerged that have much thread level parallelism (TLP), it will be very effective if we exploit TLP with processors that emphasizes multi-thread performances. This paper clearly outlined the structure of the Niagara processor, provided details on its thread selection policies and cache design, and gave clear examples. 

Due to limitations in memory access speeds, exploiting ILP have shown diminishing returns. Using machines that are optimized for single-thread performance as commercial servers have also shown inefficiency, which is especially true for commercial servers deployed in large scale. This is because commercial server applications usually have large TLP, so having a machine optimized for multi-thread performance will boost performance and efficiency. Some of these applications are running on symmetric multiprocessor systems, which are not power nor cost efficient, thus current implementations have shifted to aggregate cores on a single die. Niagara have also adopted such a design, and supports 32 threads of execution. It consists of 8 thread groups, each running 4 threads. Within each of these thread groups, the threads share a processing pipeline, which consists of functional units, L1 cache, etc. Threads within a thread group are fetched in parallel, and are scheduled by the thread scheduler to execute. The 8 thread groups then share the same L2 cache, which is interconnected by a crossbar with a very high bandwidth. L1 caches are designed to be write-through, and L2 cache is write-back, similar to other designs. The thread scheduler chooses within the ready threads the one with highest priority, and makes its decision partly based on the type of instruction executed. For example, divide and multiply operations which have a high latency would trigger a thread switch. In addition, the thread scheduler assumes that loads are cache hits, but would assign a lower priority to these instructions. The Niagara’s register files adopt a very interesting register window implementation, which is specified by the SPARK v9 architecture, where in and out register swap between windows, and window shifts can be requested by procedure calls.

In conclusion, the Niagara processor is designed to handle commercial server workloads, which have high TLP. I think the motivation of designing the Niagara processor, which aims to handle server applications efficiently, still works today. We can still see similar design concepts on today’s Intel Xeon processors. The design of thread groups in Niagara is similar to the Hyper-Threading technology of Intel, which is used on current Intel Core i7 and Xeon E7 processors. However, this paper hasn’t given experiment results, so we have no idea how hits processor performs on actual programs, or whether particular processor parameters should be adjusted. In addition, this design may be the best of its time, but with the advances in manufacturing technology, we can probably come up with better designs today. For example, it is now feasible to add a on-board LLC.  
