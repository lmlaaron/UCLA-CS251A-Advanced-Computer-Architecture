This 2001 paper introduces the concept of speculative multithreaded processors. The author first introduces current trends and means in improving microprocessor performance, identified their limitations, and then introduces the concept of speculative multithreading. The author also gave a high-level overview on how to divide programs into multiple threads, which can be primarily categorized into control-driven and data-driven. The author also briefly mentioned the system architectures needed to support speculative multithreading.

Due to emerging limitations in implementing single-chip processors, there’s a shift of interest from implementing monolithic single-core designs with high single-thread performance, to exploiting thread-level parallelism using multithreading or multiprocessing. However, processors that optimizes single-thread performance is limited by the limited ILP inherent to the program, and multi-thread options (either simultaneous multithreading or chip multiprocessing) require explicitly parallel threads, which rest on programmers or compilers. Different from these two directions comes speculative multithreading, which executes parallel execution of a single program. Speculative multithreading divides a thread into chunks, and these threads are reasonably independent, which can be speculatively executed in parallel. There are several ways to divide a program into multiple threads, which mainly consists of control-driven or data-driven approaches. In control-driven multithreading, threads are divided at control-flow boundaries, and each program segment are concatenated end-to-end to during reconstruction. Control-driven division does not require explicit data flow synchronization, as data always flow from older instruction to newer instructions. Without speculation, we are constrained by data integrity, which imposes restrictions on thread execution order. With speculation, such restrictions can be relaxed, where access to shared data can process opportunistically, and recover if violation is detected. Data-driven multithreading uses data-flow boundaries to divide the program, which is a natural choice to achieve data-dependence between threads. Without speculation, it is usually hard to achieve data-driven multithreading with imperative programs. This is because data-flow boundaries are not explicitly defined, and compilers are conservative in optimization to maintain correctness. With speculation, we can solve these problems by having a main thread which executes the full program, as well as a few data-driven threads which performs ancillary work. These data-driven threads run ahead of main threads, and filter latencies for the main thread. Besides thread division strategies, there are also problems as to where should these support for speculative multithreading be implemented. One possible solution is to rely on the processor itself, which is an attractive solution not only because of its feasibility, but also that it’s a self-contained solution with no compatibility problems. It is also possible to rely on programmers or compilers, which may generate better thread divisions. However, having these support in hardware requires modifications to existing architectures.

In conclusion, this paper proposed the notion of speculative multithreading, which is a novel idea to exploit parallelism between ILP and TLP. Although such a design may improve performance, it is unclear that whether it improves efficiency, which is becoming more and more important from mobile devices to data centers.